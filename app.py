import json
import os
import subprocess
from datetime import datetime
from typing import Any

import pandas as pd
import pytz
import streamlit as st
from loguru import logger
from streamlit_autorefresh import st_autorefresh


def load_departures_data() -> dict[str, Any] | None:
    """Load departure data from JSON file generated by Node.js script"""
    json_file = "departures.json"

    if not os.path.exists(json_file):
        logger.error(f"Departures JSON file not found: {json_file}")
        st.error("Departure data not available. Please run the data fetcher first.")
        return None

    try:
        with open(json_file, "r", encoding="utf-8") as f:
            data = json.load(f)

        # Handle both old and new JSON formats for backward compatibility
        if "journey" in data:
            # Old format - convert to new format
            logger.info("Converting old format to new bidirectional format")
            data = {
                "badVoeslauToWien": data.get("journey", []),
                "wienToBadVoeslau": [],
                "lastUpdated": data.get("lastUpdated", ""),
                "stations": {"badVoeslau": data.get("station", {}), "wienHbf": None},
            }

        bad_voeslau_count = len(data.get("badVoeslauToWien", []))
        wien_count = len(data.get("wienToBadVoeslau", []))

        logger.info(
            f"Loaded {bad_voeslau_count} Bad VÃ¶slauâ†’Wien + {wien_count} Wienâ†’Bad VÃ¶slau departures from {json_file}"
        )
        logger.info(f"Data last updated: {data.get('lastUpdated', 'Unknown')}")
        return data
    except Exception as e:
        logger.error(f"Error loading departure data: {e}")
        st.error(f"Error loading departure data: {e}")
        return None


def fetch_fresh_data() -> bool:
    """Fetch fresh departure data by running the Node.js script"""
    try:
        logger.info("Fetching fresh departure data from Ã–BB API...")

        # Run the Node.js script to fetch new data
        result = subprocess.run(
            ["node", "fetch_departures.js"],
            capture_output=True,
            text=True,
            timeout=30,  # 30 second timeout
        )

        if result.returncode == 0:
            logger.info("Successfully fetched fresh departure data")
            logger.debug(f"Node.js output: {result.stdout}")
            return True
        else:
            logger.error(f"Node.js script failed with return code {result.returncode}")
            logger.error(f"Error output: {result.stderr}")
            st.error(f"Failed to fetch fresh data: {result.stderr}")
            return False

    except subprocess.TimeoutExpired:
        logger.error("Timeout while fetching fresh data")
        st.error("Timeout while fetching fresh data. Please try again.")
        return False
    except FileNotFoundError:
        logger.error("Node.js or fetch_departures.js not found")
        st.error(
            "Data fetcher script not found. Please ensure Node.js is installed and fetch_departures.js exists."
        )
        return False
    except Exception as e:
        logger.error(f"Unexpected error while fetching fresh data: {e}")
        st.error(f"Unexpected error while fetching data: {e}")
        return False


def format_time(time_str: str | None) -> str:
    """Format time string for display"""
    if time_str:
        return time_str
    return "N/A"


def is_data_stale(departures_data: dict[str, Any], max_age_seconds: int) -> bool:
    """Check if the departure data is older than max_age_seconds"""
    if not departures_data:
        return True

    last_updated_str = departures_data.get("lastUpdated", "")
    if not last_updated_str:
        logger.warning("No lastUpdated timestamp found in data")
        return True

    try:
        last_updated = datetime.fromisoformat(last_updated_str.replace("Z", "+00:00"))
        current_time = datetime.now(last_updated.tzinfo)
        age_seconds = (current_time - last_updated).total_seconds()

        logger.debug(f"Data age: {age_seconds:.1f}s, max age: {max_age_seconds}s")
        return age_seconds > max_age_seconds

    except (ValueError, TypeError) as e:
        logger.warning(f"Could not parse lastUpdated timestamp: {e}")
        return True


def calculate_delay(scheduled: str | None, actual: str | None) -> int:
    """Calculate delay in minutes"""
    if not actual or not scheduled:
        return 0
    try:
        # Simple time comparison (assumes same day)
        sched_parts = scheduled.split(":")
        actual_parts = actual.split(":")

        sched_minutes = int(sched_parts[0]) * 60 + int(sched_parts[1])
        actual_minutes = int(actual_parts[0]) * 60 + int(actual_parts[1])

        return actual_minutes - sched_minutes
    except (ValueError, IndexError):
        return 0


def create_train_table(trains: list[dict[str, Any]], direction_label: str) -> None:
    """Create and display a train table for a given direction"""
    if not trains:
        st.warning(f"No {direction_label} departures found in the current data.")
        return

    # Create DataFrame
    train_data = []

    for train in trains:
        # Handle None train objects
        if train is None:
            continue

        scheduled_time = train.get("ti", "N/A")
        actual_time = (
            train.get("rt", {}).get("dlt") if train.get("rt") else scheduled_time
        )
        delay_minutes = (
            calculate_delay(scheduled_time, actual_time)
            if actual_time != scheduled_time
            else 0
        )

        train_data.append(
            {
                "Departure": format_time(scheduled_time),
                "Actual": format_time(actual_time)
                if actual_time != scheduled_time
                else "âœ“ On time",
                "Delay (min)": str(delay_minutes) if delay_minutes > 0 else "â€”",
                "Train": train.get("pr", "Unknown"),
                "Platform": train.get("tr", "TBA"),
            }
        )

    df = pd.DataFrame(train_data)

    # Display table with styling
    st.dataframe(
        df,
        use_container_width=True,
        hide_index=True,
        column_config={
            "Departure": st.column_config.TextColumn("Scheduled", width="small"),
            "Actual": st.column_config.TextColumn("Actual/Status", width="medium"),
            "Delay (min)": st.column_config.TextColumn("Delay", width="small"),
            "Train": st.column_config.TextColumn("Train Type", width="small"),
            "Platform": st.column_config.TextColumn("Platform", width="small"),
        },
    )


def get_direction_data(
    departures_data: dict[str, Any],
) -> tuple[list[dict[str, Any]], list[dict[str, Any]]]:
    """Extract train data for both directions from departures data"""
    if not departures_data:
        return [], []

    bad_voeslau_to_wien = departures_data.get("badVoeslauToWien", [])
    wien_to_bad_voeslau = departures_data.get("wienToBadVoeslau", [])

    logger.debug(
        f"Successfully loaded {len(bad_voeslau_to_wien)} Bad VÃ¶slauâ†’Wien + {len(wien_to_bad_voeslau)} Wienâ†’Bad VÃ¶slau departures"
    )

    return bad_voeslau_to_wien, wien_to_bad_voeslau


def format_last_updated_display(last_updated_str: str) -> str | None:
    """Format last updated timestamp for display in Vienna timezone"""
    if not last_updated_str:
        return None

    try:
        vienna_tz = pytz.timezone("Europe/Vienna")
        last_updated = datetime.fromisoformat(last_updated_str.replace("Z", "+00:00"))
        last_updated_vienna = last_updated.astimezone(vienna_tz)
        return last_updated_vienna.strftime("%H:%M:%S")
    except (ValueError, TypeError) as e:
        logger.warning(f"Could not parse lastUpdated timestamp: {e}")
        return None


def determine_tab_order(current_time: datetime | None = None) -> tuple[bool, list[str]]:
    """Determine tab order based on time of day (afternoon prioritizes homebound traffic)"""
    if current_time is None:
        vienna_tz = pytz.timezone("Europe/Vienna")
        current_time = datetime.now(vienna_tz)

    is_afternoon = current_time.hour >= 12

    if is_afternoon:
        # After midday, show Wien â†’ Bad VÃ¶slau first (homebound traffic)
        tab_labels = ["ðŸš‚ Wien Hbf â†’ Bad VÃ¶slau", "ðŸš‚ Bad VÃ¶slau â†’ Wien Hbf"]
    else:
        # Morning: show Bad VÃ¶slau â†’ Wien first (work commute)
        tab_labels = ["ðŸš‚ Bad VÃ¶slau â†’ Wien Hbf", "ðŸš‚ Wien Hbf â†’ Bad VÃ¶slau"]

    return is_afternoon, tab_labels


def should_auto_refresh(
    departures_data: dict[str, Any] | None, refresh_interval: int = 60
) -> bool:
    """Determine if data should be automatically refreshed"""
    return departures_data is not None and is_data_stale(
        departures_data, refresh_interval
    )


def main() -> None:
    logger.info("=== Starting Streamlit application ===")
    st_autorefresh(interval=60000, key="refresh")
    st.set_page_config(
        page_title="Bad VÃ¶slau â†” Wien Hbf Trains",
        page_icon="ðŸš‚",
        layout="wide",
        initial_sidebar_state="collapsed",
    )

    st.title("ðŸš‚ Bad VÃ¶slau â†” Wien Hauptbahnhof")
    st.subheader("Live Train Departures")

    # Auto-fetch fresh data if cached data is stale
    logger.info("Loading train data for display")
    refresh_interval = 60
    with st.spinner("Loading train data..."):
        logger.debug("Loading departure data from JSON file")
        departures_data = load_departures_data()

    if should_auto_refresh(departures_data, refresh_interval):
        logger.info("Cached data is stale, fetching fresh data automatically")
        update_data()

    # Create columns for layout
    col1, col2 = st.columns([3, 1])

    with col1:
        st.write(
            "Showing trains in both directions between Bad VÃ¶slau and Wien Hauptbahnhof"
        )

    with col2:
        if st.button("ðŸ”„ Refresh Now"):
            with st.spinner("Fetching fresh train data from Ã–BB API..."):
                update_data()

    # Always load and display data
    logger.info("Loading train data for display")
    with st.spinner("Loading train data..."):
        logger.debug("Loading departure data from JSON file")
        departures_data = load_departures_data()

        if departures_data:
            # Get train data for both directions
            bad_voeslau_to_wien, wien_to_bad_voeslau = get_direction_data(
                departures_data
            )

            # Display data freshness information
            last_updated_str = departures_data.get("lastUpdated", "")
            formatted_time = format_last_updated_display(last_updated_str)
            if formatted_time:
                st.write(f"**Data fetched:** {formatted_time} (Vienna time)")

            # Create tabs for both directions - order based on time of day
            is_afternoon, tab_labels = determine_tab_order()
            tab1, tab2 = st.tabs(tab_labels)

            if is_afternoon:
                with tab1:
                    st.subheader("Departures from Wien Hauptbahnhof to Bad VÃ¶slau")
                    create_train_table(wien_to_bad_voeslau, "Wien â†’ Bad VÃ¶slau")

                with tab2:
                    st.subheader("Departures from Bad VÃ¶slau to Wien Hauptbahnhof")
                    create_train_table(bad_voeslau_to_wien, "Bad VÃ¶slau â†’ Wien")
            else:
                with tab1:
                    st.subheader("Departures from Bad VÃ¶slau to Wien Hauptbahnhof")
                    create_train_table(bad_voeslau_to_wien, "Bad VÃ¶slau â†’ Wien")

                with tab2:
                    st.subheader("Departures from Wien Hauptbahnhof to Bad VÃ¶slau")
                    create_train_table(wien_to_bad_voeslau, "Wien â†’ Bad VÃ¶slau")

        else:
            st.error(
                "Could not load departure data. Please run the Node.js fetcher script first."
            )

        st.session_state.last_update = datetime.now()
        logger.debug(
            f"Updated session state last_update to: {st.session_state.last_update}"
        )


def update_data() -> bool:
    """Update data and return success status"""
    if fetch_fresh_data():
        logger.info("Successfully fetched fresh data, reloading")
        st.rerun()
        return True
    else:
        logger.warning("Failed to fetch fresh data, using cached data")
        return False


if __name__ == "__main__":
    main()
